# DNS (Domain Name System)
도메인 네임 시스템은 호스트의 도메인 이름을 호스트의 네트워크 주소로 바꾸거나 네트워크 주소를 도메인 이름으로 변환할 수 있도록 하기 위한 시스템이다.

# 웹페이지가 브라우저에 렌더링되는 과정
1. 브라우저에 url 입력
2. HTML, CSS, image, JavaScript 등의 리소스를 요청한다.
3. HTML로 DOM 트리를 생성한다.
4. 화면에 보여준다.

# 브라우저 동작 원리
사용자가 참조하고자 하는 웹페이지를 서버에 요청한다.
서버로부터 HTML, CSS, JAVASCRIPT, IMAGE 파일 등을 입력받는다.
HTML, CSS 파일은 각가의 파서(PARSER)에 의해 DOM, CSSOM 트리로 변환되고 렌더 트리로 결합된다.
JAVASCRIPT는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다.
HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.
제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.
브라우저는 동기적으로 HTML, CSS, JAVASCRIPT를 처리한다.
이것은 script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다.
따라서 script 태그의 위치는 중요한 의미를 갖는다.
body 요소의 가장 아래에 자바스크립트를 위치시키는 것이 좋다.
이유는, 
HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.
DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생한다.

### 브라우저의 주요 기능
사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것.

크롬은 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지한다. 각 탭은 독립된 프로세스로 처리된다.

# 렌더링 엔진
요청받은 내용을 브라우저 화면에 표시하는 것.
렌더링 엔진은 통신으로부터 요천한 문서의 내용을 얻는 것으로 시작하는데 문서의 내용은 보통 8KB 단위로 전송된다.
동작 과정은,
DOM 트리구축을 위한 HTML 파싱 -> 렌더 트리 구축 -> 렌더 트리 배치 -> 렌더 트리 그리기
이다.

렌더링 엔진은 HTML 문서를 파싱하고 태그를 DOM 노드로 변환한다. 그 다음 외부 CSS 파일과 함께 포함된 스타일 요소도 파싱한다. 스타일 정보와 HTML 표시 규칙은 렌더트리를 생성한다.

렌더 트리는 색상 또는 면적과 같은 것들을 포함하고 있는데 정해진 순서대로 화면에 표시된다.

렌더트리 생성이 끝나면 배치가 시작되는데 이것은 각 노드가 화면의 정확한 위치에 표시되는 것이다.

렌더링 엔진은 좀 더 나은 사용자 경험을 위해 가능하면 빠르게 내용을 표시하는데 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.
네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.


- - -
# SSR (Server Side Rendering)
서버에서 사용자에게 보여줄 페이지를 모두 구성하여 사용자에게 페이지를 보여주는 방식이다.
SSR을 사용하면 모든 데이터가 매핑된 서비스 페이지를 클라이언트(브라우저)에게 바로 보여줄 수 있다.
서버를 이용해 페이지를 구성하기 때문에 클라이언트에서 구성하는 CSR(Client-Side Rendering)보다 페이지를 구성하는 속도는 늦어지지만, 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 빨라진다는 장점이 있다.
또한 SEO(Search Engine Optimization)도 쉽게 구성 할 수 있다.

> SEO : 검색 엔진 최적화.
> 웹사이트가 검색 결과에 더 잘보이도록 최적화하는 과정.

반면 CSR은 SSR보다 초기 전송되는 페이지의 속도는 빠르지만 서비스에서 필요한 데이터를 클라이언트(브라우저)에서 추가로 요청하여 재구성해야 하기 때문에 전체적인 페이지 완료 시점은 SSR보다 느려진다.

SSR이 CSR보다 성능이 우수한 면이 있지만 모두 그렇지는 않다.

##### 단점
- 페이지가 더 일찍 렌더링되고 사용자가 더 빨리 페이지를 볼 수 있지만 React 실행이 완료될 때까지 상호작용 할 수 없다.
- SSR TTFB(Time To First Byte)가 CSR보다 느리다. 서버가 상대적으로 빈 응답을 보내는 대신에 사용자의 HTML 페이지를 만드는데 시간을 써야하기 때문이다.
- 서버의 SSR 처리량은 CSR처리량보다 훨씬 적다. 특히 React의 경우 부분적으로 처리량의 임팩트가 극도로 크다.

##### 장점
- 사용자를 위한 성능 이점
- 일관된 SEO 성능

성능(Performance) 측정을 위한 주요 측정항목은 보여지는 부분에 렌더이다.
SSR과 CSR의 주요 차이점은 SSR의 경우 브라우저에 대한 서버의 응답은 렌더링할 준비가 된 페이지의 HTML인 반면 CSR의 경우 브라우저는 자바스크립트 링크가 포함된 비어있는 문서를 가져온다.
그래서 SSR은 모든 자바스크립트가 다운로드 및 실행될 때까지 기다릴 필요 없이 브라우저가 서버에서 HTML 렌더링을 시작한다.
두 경우에 모두 React를 다운로드하고 페이지를 대화형으로 만들기 위해 가상 DOM을 만들고 이벤트를 첨부하는 프로세스를 거쳐야한다.
그러나 SSR의 경우 이 모든 일이 진행되는 동안 사용자가 페이지 보기를 시작할 수 있다.
CSR은 위의 프로세스를 기다린 다음 페이지를 볼 수 있도록 가상 DOM을 브라우저 DOM으로 이동해야 한다.
- - -
# WebPack
모던 자바스크립트 애플리케이션을 위한 정적 모듈 번들러이다. 웹팩이 애플리케이션을 처리할 때, 내부적으로는 프로젝트에 필요한 모든 모듈을 매핑하고 하나 이상의 번들을 생성하는 디펜던시 그래프를 만든다.

- 모듈(module)
모듈 프로그래밍에서 개별적인 기능을 하는 작은 단위

### 웹팩의 기능
- Uglify
자바스크립트 코드 자체를 분석하기 어렵게 만드는 과정이다.
난독화를 했다고 보안처리 없이 중요 정보나 루틴을 자바스크립트에 넣는 것은 매우 위험할 수 있다.
변수명, 함수명 치환에서부터 자바스크립트의 일부 루틴을 문자열로 바꿔 변수에 담고 뒤섞는 단계 등 여러단계가 존재한다.
난독화의 단계를 높일수록 루틴을 알아보기 어렵게 만들 수 있다.
변수, 함수명 등이 줄어 용량이 감소하지만 난독화 단계를 높일수록 코드를 해석하고 실행하는 속도가 느려질 수 있으므로, 프로젝트에 맞게 선택하여 적용하는 것이 좋다.

- Minify
불필요한 줄바꿈
공백 밑 들여쓰기
짧게 쓸 수 있는 긴 구문(줄일 수 있는 if 구문, 형 변환 축약 등)
스코프 내 사용하지 않는 변수
주석
경우에따라 console.log, debugger 등의 디버깅용 구문 또는 메서드 호출
무의미한 메서드 호출 및 루프
같이 전체 소스코드 중 위에 언급된 경우를 제거하는 작업이 압축(Minify)이다.
--유의점
코드 압축시, 모든 들여쓰기와 공백이 제거되고 전체 코드가 한 줄로 병합된다.
원본 코드에서 들여쓰기, 공백, 세미콜론, 콤마, 대괄호 등이 바르게 사용되지 않았을 경우 압축된 코드가 정상적으로 동작하지 않을 수 있다.
자바스크립트는 명시적으로 수행되는 컴파일 과정이 없어 이런 오류를 사전에 알아내는 것은 쉽지 않다.
난독화 도구는 하드코딩된 코드를 처리할 수 없으므로, 하드코딩을 피하는 것이 좋다.
- Bundling
- - -
# SPA (Single Page Application)
#### 장점
- 새로고침이 빠르다. 마치 새로고침이 일어나지 않는 것처럼 된다.